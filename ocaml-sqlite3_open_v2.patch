diff ocaml-sqlite3-release-1.5.9/sqlite3.ml ocaml-sqlite3-mlin/sqlite3.ml
136a137,153
> 
> type open_flag =
>   | OPEN_READONLY
>   | OPEN_READWRITE
>   | OPEN_CREATE
>   
>   | OPEN_NOMUTEX
>   | OPEN_FULLMUTEX
>   | OPEN_SHAREDCACHE
>   | OPEN_PRIVATECACHE
> 
> external db_open_v2_stub : string -> open_flag list -> string option -> db = "caml_sqlite3_open_v2"
> let db_open_v2 ?(flags=[OPEN_READWRITE; OPEN_CREATE]) ?vfs fn =
>   if not (List.mem OPEN_READONLY flags || List.mem OPEN_READWRITE flags) then
>     invalid_arg "Sqlite3.db_open_v2: invalid flags";
>   db_open_v2_stub fn flags vfs
> 
diff ocaml-sqlite3-release-1.5.9/sqlite3.mli ocaml-sqlite3-mlin/sqlite3.mli
162a163,177
> (** flags for use with [db_open_v2] (see the SQLite API documentation for semantics) *)
> type open_flag =
>   | OPEN_READONLY
>   | OPEN_READWRITE
>   | OPEN_CREATE
>   
>   | OPEN_NOMUTEX
>   | OPEN_FULLMUTEX
>   | OPEN_SHAREDCACHE
>   | OPEN_PRIVATECACHE
>   
> val db_open_v2 : ?flags:open_flag list -> ?vfs:string -> string -> db
> (** [db_open_v2 filename] opens the database file [filename] while allowing you to specify flags
> and the VFS object to use (see the SQLite API documentation for more information) *)
> 
diff ocaml-sqlite3-release-1.5.9/sqlite3_stubs.c ocaml-sqlite3-mlin/sqlite3_stubs.c
344a345,412
> CAMLprim value caml_sqlite3_open_v2(value v_file, value v_flags, value v_vfs)
> {
>   sqlite3 *db;
>   int res;
>   char *vfs = NULL;
>   int sqlite_flags = 0;
>   
>   /* must be same order as caml open_flags union type */
>   enum { CAML_OPEN_READONLY, CAML_OPEN_READWRITE, CAML_OPEN_CREATE, CAML_OPEN_NOMUTEX,
>          CAML_OPEN_FULLMUTEX, CAML_OPEN_SHAREDCACHE, CAML_OPEN_PRIVATECACHE };
> 
>   int len = caml_string_length(v_file) + 1;
>   char *file = caml_stat_alloc(len);
>   memcpy(file, String_val(v_file), len);
>   
>   if(Is_block(v_vfs)) {
>     value some_vfs = Field(v_vfs,0);
>     int len_vfs = caml_string_length(some_vfs);
> 	vfs = caml_stat_alloc(len_vfs);
> 	memcpy(vfs, String_val(some_vfs), len_vfs);
>   }
>     
>   while(Is_block(v_flags)) {
>     #define FLAG_CASE(flag) case CAML_ ## flag: sqlite_flags |= SQLITE_ ## flag; break;
> 	switch(Val_int(Field(v_flags,0))) {
> 		FLAG_CASE(OPEN_READONLY)
> 		FLAG_CASE(OPEN_READWRITE)
> 		FLAG_CASE(OPEN_CREATE)
> 		FLAG_CASE(OPEN_NOMUTEX)
> 		FLAG_CASE(OPEN_FULLMUTEX)
> 		FLAG_CASE(OPEN_SHAREDCACHE)
> 		FLAG_CASE(OPEN_PRIVATECACHE)
> 	}
>     v_flags = Field(v_flags,1);
>   }
> 
>   caml_enter_blocking_section();
>     res = sqlite3_open_v2(file, &db, sqlite_flags, vfs);
>     free(file);
> 	if(vfs) free(vfs);
>   caml_leave_blocking_section();
> 
>   if (res) {
>     const char *msg;
>     if (db) {
>       msg = sqlite3_errmsg(db);
>       sqlite3_close(db);
>     }
>     else msg = "<unknown_error>";
>     raise_sqlite3_Error("error opening database: %s", msg);
>   } else if (db == NULL)
>     raise_sqlite3_InternalError(
>       "open returned neither a database nor an error");
>   /* "open" succeded */
>   {
>     db_wrap *dbw;
>     value v_res = caml_alloc_final(2, dbw_finalize_gc, 1, 100);
>     Sqlite3_val(v_res) = NULL;
>     dbw = caml_stat_alloc(sizeof(db_wrap));
>     dbw->db = db;
>     dbw->rc = SQLITE_OK;
>     dbw->ref_count = 1;
>     dbw->user_functions = NULL;
>     Sqlite3_val(v_res) = dbw;
>     return v_res;
>   }
> }
> 
